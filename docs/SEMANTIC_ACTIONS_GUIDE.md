# Semantic Actions Guide

## Overview

The Architech uses **Semantic Actions** - high-level, intent-driven actions that abstract away implementation complexity. Instead of writing low-level file manipulation code, blueprint authors express their intent, and the system handles the implementation details.

## Architecture

```
Blueprint Author → Semantic Actions → Blueprint Orchestrator → File Modification Engine → File System
     (Intent)           (Translation)           (Primitives)           (Disk)
```

### Three-Layer System

1. **Layer 3: Blueprint Executor** - Orchestrates blueprint execution
2. **Layer 2: Blueprint Orchestrator** - Translates semantic actions to primitives  
3. **Layer 1: File Modification Engine** - Core file operations with VFS

## Available Semantic Actions

### 1. CREATE_FILE
Creates new files with content.

```typescript
{
  type: 'CREATE_FILE',
  path: 'src/components/Button.tsx',
  content: 'export const Button = () => { return <button>Click me</button>; };'
}
```

### 2. INSTALL_PACKAGES
Adds dependencies to package.json.

```typescript
{
  type: 'INSTALL_PACKAGES',
  packages: ['react', 'react-dom', '@types/react'],
  isDev: false  // optional, defaults to false
}
```

### 3. ADD_SCRIPT
Adds npm scripts to package.json.

```typescript
{
  type: 'ADD_SCRIPT',
  name: 'build',
  command: 'tsc && next build'
}
```

### 4. ADD_ENV_VAR
Adds environment variables to .env files.

```typescript
{
  type: 'ADD_ENV_VAR',
  key: 'DATABASE_URL',
  value: 'postgresql://localhost:5432/mydb',
  description: 'Database connection string'
}
```

### 5. ADD_TS_IMPORT
Adds TypeScript imports to existing files.

```typescript
{
  type: 'ADD_TS_IMPORT',
  path: 'src/lib/auth.ts',
  imports: [
    {
      moduleSpecifier: 'next-auth',
      namedImports: ['NextAuthOptions', 'NextAuth']
    }
  ]
}
```

### 6. MERGE_JSON
Merges JSON configuration files.

```typescript
{
  type: 'MERGE_JSON',
  path: 'tsconfig.json',
  content: {
    compilerOptions: {
      strict: true,
      target: 'ES2020'
    }
  }
}
```

### 7. APPEND_TO_FILE
Appends content to existing files.

```typescript
{
  type: 'APPEND_TO_FILE',
  path: 'README.md',
  content: '\n## Installation\n\nRun `npm install` to install dependencies.'
}
```

### 8. PREPEND_TO_FILE
Prepends content to existing files.

```typescript
{
  type: 'PREPEND_TO_FILE',
  path: 'src/index.ts',
  content: '// Generated by The Architech\n'
}
```

### 9. ENHANCE_FILE
Performs complex file modifications using registered modifiers with smart fallback mechanism.

```typescript
{
  type: 'ENHANCE_FILE',
  path: 'src/app/api/auth/[...all]/route.ts',
  modifier: 'ts-module-enhancer',
  fallback: 'create',  // Smart fallback strategy
  params: {
    importsToAdd: [
      { name: 'toNextJsHandler', from: 'better-auth/next-js', type: 'import' },
      { name: 'authHandler', from: '@/lib/auth/config', type: 'import' }
    ],
    statementsToAppend: [
      {
        type: 'raw',
        content: `export const { GET, POST } = toNextJsHandler(authHandler);`
      }
    ]
  }
}
```

#### Fallback Strategies

The `fallback` property controls what happens when the target file doesn't exist:

- **`'create'`** (Recommended for API routes): Auto-create the file if it doesn't exist
- **`'skip'`**: Skip the action silently if file doesn't exist
- **`'error'`** (Default): Throw an error if file doesn't exist

#### Smart Fallback Examples

```typescript
// API Route Creation - Auto-create missing files
{
  type: 'ENHANCE_FILE',
  path: 'src/app/api/stripe/webhooks/route.ts',
  modifier: 'ts-module-enhancer',
  fallback: 'create',  // Will create the file if it doesn't exist
  params: { /* ... */ }
}

// Configuration Enhancement - Skip if file doesn't exist
{
  type: 'ENHANCE_FILE',
  path: 'next.config.js',
  modifier: 'nextjs-config-wrapper',
  fallback: 'skip',  // Will skip if next.config.js doesn't exist
  params: { /* ... */ }
}

// Critical Enhancement - Fail if file doesn't exist
{
  type: 'ENHANCE_FILE',
  path: 'src/lib/auth/config.ts',
  modifier: 'ts-module-enhancer',
  fallback: 'error',  // Will throw error if file doesn't exist
  params: { /* ... */ }
}
```

#### When to Use Each Fallback Strategy

| Strategy | Use Case | Example |
|----------|----------|---------|
| `'create'` | API routes, new files | Stripe webhook routes, auth API routes |
| `'skip'` | Optional enhancements | Config file enhancements, optional features |
| `'error'` | Critical modifications | Core file modifications, required features |

### 10. RUN_COMMAND
Executes CLI commands.

```typescript
{
  type: 'RUN_COMMAND',
  command: 'npx shadcn-ui@latest init',
  workingDir: './src'  // optional
}
```

## Template Variables

All actions support template variables using `{{variable}}` syntax:

```typescript
{
  type: 'CREATE_FILE',
  path: 'src/components/{{componentName}}.tsx',
  content: 'export const {{componentName}} = () => { ... };'
}
```

Available variables:
- `{{project.name}}` - Project name
- `{{project.path}}` - Project path
- `{{module.id}}` - Module ID
- `{{module.parameters.paramName}}` - Module parameters

## Conditional Execution

Actions can be conditionally executed:

```typescript
{
  type: 'INSTALL_PACKAGES',
  packages: ['@types/node'],
  condition: '{{module.parameters.typescript}}'
}
```

## Migration from ADD_CONTENT

### Before (Legacy)
```typescript
{
  type: 'ADD_CONTENT',
  target: 'package.json',
  content: '{"dependencies": {"react": "^18.0.0"}}',
  strategy: 'merge'
}
```

### After (Semantic)
```typescript
{
  type: 'INSTALL_PACKAGES',
  packages: ['react@^18.0.0']
}
```

## Benefits

### For Blueprint Authors
- **Simpler Syntax** - 50% fewer lines per action
- **Clear Intent** - Action names match purpose
- **Better Error Messages** - Specific validation per action
- **Type Safety** - Compile-time validation

### For System Maintainability
- **Reduced Complexity** - 600+ lines of legacy code removed
- **Better Testing** - Each action can be tested independently
- **Easier Debugging** - Clear action-to-primitive mapping
- **Future-Proof** - Easy to add new semantic actions

## Best Practices

1. **Use the most specific action** for your use case
2. **Prefer semantic actions** over generic ADD_CONTENT
3. **Use ENHANCE_FILE** only for complex, technology-specific modifications
4. **Test your blueprints** after migration
5. **Use template variables** for dynamic content

## Examples

See `examples/semantic-actions-example.ts` for comprehensive examples of all semantic actions.