# Plugin Architecture - Consolidated Design

## Overview

This document outlines the improved plugin architecture that consolidates plugin files into unified plugin modules with unified interface file generation, providing better separation of concerns and marketplace-ready structure.

## Architecture Layers

### 1. Main Orchestrator Agent
- **Role**: Controls overall project generation flow
- **Responsibilities**:
  - Analyze user requirements
  - Coordinate specialized agents
  - Manage project lifecycle
  - Handle rollbacks and error recovery

### 2. Specialized Agents
- **Role**: Handle domain-specific user flow and decision-making
- **Responsibilities**:
  - Transform high-level requirements into specific implementations
  - Handle user interactions for their domain
  - Import and use unified interface files generated by plugins
  - Manage domain-specific configuration

### 3. Consolidated Plugins
- **Role**: Provide actual implementation and generate unified interface files
- **Structure**: Single file containing plugin logic and unified interface generation
- **Responsibilities**:
  - Install and configure specific libraries
  - Generate unified interface files for their domain
  - Handle library-specific configuration
  - Provide templates and utilities

### 4. Structure Service
- **Role**: Centralized project structure management
- **Responsibilities**:
  - Path resolution for different project types (single app vs monorepo)
  - Structure transformation capabilities
  - Unified interface file location management
  - Clean APIs for agents and plugins

### 5. Plugin Registry Layer
- **Role**: Manage plugin ecosystem
- **Responsibilities**:
  - Plugin discovery and registration
  - Version management and compatibility
  - Dependency resolution
  - Error handling and validation
  - Marketplace integration

## Consolidated Plugin Structure

```typescript
// Example: src/plugins/database/drizzle-plugin.ts
export class DrizzlePlugin implements DatabasePlugin {
  // Plugin metadata
  metadata = {
    name: 'drizzle',
    version: '1.0.0',
    description: 'Drizzle ORM for TypeScript',
    category: 'database',
    dependencies: ['drizzle-orm', 'postgres'],
    compatibility: ['postgresql', 'mysql', 'sqlite']
  };

  // Plugin implementation
  async install(context: PluginContext): Promise<InstallResult> {
    // Install Drizzle ORM
    // Configure database connection
    // Generate schema files
    // Set up migrations
    // Generate unified interface file
    await this.generateUnifiedInterface(context.projectPath);
  }

  // Generate unified interface file
  private async generateUnifiedInterface(projectPath: string): Promise<void> {
    const structure = structureService.getStructure(projectPath);
    const interfacePath = structureService.resolvePath('database', projectPath);
    
    const interfaceContent = `
      import { drizzle } from 'drizzle-orm/postgres-js';
      import postgres from 'postgres';
      
      export interface UnifiedDatabase {
        client: ReturnType<typeof drizzle>;
        schema: typeof import('./schema');
        migrations: {
          generate: () => Promise<void>;
          run: () => Promise<void>;
        };
        connection: {
          connect: () => Promise<void>;
          disconnect: () => Promise<void>;
        };
      }
      
      export const createDatabaseInterface = (): UnifiedDatabase => {
        // Drizzle-specific implementation
        return {
          client: drizzle(postgres(process.env.DATABASE_URL)),
          schema: require('./schema'),
          migrations: {
            generate: async () => { /* Drizzle migration generation */ },
            run: async () => { /* Drizzle migration execution */ }
          },
          connection: {
            connect: async () => { /* Drizzle connection */ },
            disconnect: async () => { /* Drizzle disconnection */ }
          }
        };
      };
    `;
    
    await fs.writeFile(path.join(interfacePath, 'unified-database.ts'), interfaceContent);
  }

  // Plugin-specific utilities
  getTemplates(): Template[] {
    return [
      { name: 'schema.ts', content: '...' },
      { name: 'migrations/', content: '...' }
    ];
  }
}
```

## Unified Interface File System

### File Structure
```
project/
├── apps/
│   └── web/                 # Next.js app (monorepo)
├── packages/
│   ├── ui/                  # UI package (monorepo)
│   │   └── unified-ui.ts    # Generated unified interface
│   ├── db/                  # Database package (monorepo)
│   │   └── unified-database.ts # Generated unified interface
│   └── auth/                # Auth package (monorepo)
│       └── unified-auth.ts  # Generated unified interface
└── unified-interfaces/      # Single app unified interfaces
    ├── unified-ui.ts
    ├── unified-database.ts
    └── unified-auth.ts
```

### Agent Usage
```typescript
// Example: DBAgent using unified interface
export class DBAgent extends BaseAgent {
  async execute(context: AgentContext): Promise<AgentResult> {
    const structure = structureService.getStructure(context.projectPath);
    const dbPath = structureService.resolvePath('database', context.projectPath);
    
    // Import generated unified interface
    const { createDatabaseInterface } = await import(path.join(dbPath, 'unified-database.ts'));
    
    // Use unified interface
    const db = createDatabaseInterface();
    await db.migrations.generate();
    await db.connection.connect();
    
    return { success: true };
  }
}
```

## Benefits of Consolidated Structure

### 1. Simplified Development
- Single file per plugin
- Clear separation between plugin logic and interface generation
- Easier to maintain and update
- No adapter complexity

### 2. Marketplace Ready
- Self-contained plugins
- Version management
- Dependency tracking
- Easy distribution
- Generated files provide clear interfaces

### 3. Better Error Handling
- Centralized error management
- Plugin-specific error recovery
- Better debugging
- Clear interface boundaries

### 4. Enhanced Flexibility
- Easy plugin switching
- Unified interfaces prevent lock-in
- Extensible architecture
- Structure service handles path resolution

### 5. Clean Architecture
- Agents focus on orchestration
- Plugins focus on implementation
- Structure service handles project organization
- Clear separation of concerns

## Migration Plan

### Phase 1: Create Consolidated Plugin Structure ✅
1. ✅ Define new plugin interface
2. ✅ Create example consolidated plugins
3. ✅ Update plugin registry
4. ✅ Implement structure service

### Phase 2: Migrate Existing Plugins ✅
1. ✅ Convert plugins to generate unified interface files
2. ✅ Update specialized agents to use new structure
3. ✅ Test compatibility
4. ✅ Remove old adapter files

### Phase 3: Enhance Plugin Registry ✅
1. ✅ Add version management
2. ✅ Implement dependency resolution
3. ✅ Add marketplace features
4. ✅ Structure service integration

### Phase 4: Documentation and Examples ✅
1. ✅ Create plugin development guide
2. ✅ Provide example plugins
3. ✅ Document best practices
4. ✅ Update all documentation

## Implementation Notes

- ✅ Maintain backward compatibility during migration
- ✅ Use gradual rollout approach
- ✅ Provide migration tools for existing plugins
- ✅ Ensure unified interfaces remain stable
- ✅ Structure service provides clean APIs
- ✅ Generated files are type-safe and well-documented 