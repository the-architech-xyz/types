/**
 * Configuration Manager
 * 
 * Centralizes all project configuration handling, making the CLI
 * framework-agnostic and structure-agnostic.
 */

import * as path from 'path';
import fsExtra from 'fs-extra';
import { Logger } from '../../types/agents.js';
import { ProjectStructure, StructureInfo } from './structure-service.js';

export interface ProjectConfiguration {
  // Basic project info
  name: string;
  version: string;
  description: string;
  author: string;
  license: string;
  
  // Project structure
  structure: ProjectStructure;
  framework: string;
  
  // Package management
  packageManager: string;
  workspaces?: string[];
  
  // Features and modules
  features: string[];
  modules: string[];
  
  // Framework-specific config
  frameworkConfig: Record<string, any>;
  
  // Build and development
  scripts: Record<string, string>;
  dependencies: Record<string, string>;
  devDependencies: Record<string, string>;
  
  // Tooling configuration
  typescript: boolean;
  eslint: boolean;
  prettier: boolean;
  tailwind: boolean;
  
  // Deployment
  deployment: {
    useDocker: boolean;
    useCI: boolean;
  };
  
  // Metadata
  metadata: Record<string, any>;
}

export interface ConfigurationOptions {
  packageManager?: string;
  skipGit: boolean;
  skipInstall: boolean;
  useDefaults: boolean;
  verbose: boolean;
  dryRun?: boolean;
  force?: boolean;
}

export class ConfigurationManager {
  private logger?: Logger;

  constructor(logger?: Logger) {
    if (logger) {
      this.logger = logger;
    }
  }

  /**
   * Create project configuration from user input
   */
  createConfiguration(
    projectName: string,
    framework: string,
    structure: ProjectStructure,
    options: ConfigurationOptions,
    userInput?: string
  ): ProjectConfiguration {
    this.logger?.info(`Creating configuration for ${projectName} (${framework}, ${structure})`);

    const baseConfig: ProjectConfiguration = {
      // Basic project info
      name: projectName,
      version: '0.1.0',
      description: `A ${framework} project generated by The Architech`,
      author: 'The Architech',
      license: 'MIT',
      
      // Project structure
      structure,
      framework,
      
      // Package management
      packageManager: options.packageManager || 'npm',
      
      // Features and modules
      features: this.getDefaultFeatures(framework),
      modules: this.getDefaultModules(structure),
      
      // Framework-specific config
      frameworkConfig: this.getFrameworkConfig(framework),
      
      // Build and development
      scripts: this.getDefaultScripts(structure),
      dependencies: this.getDefaultDependencies(framework),
      devDependencies: this.getDefaultDevDependencies(framework),
      
      // Tooling configuration
      typescript: true,
      eslint: true,
      prettier: true,
      tailwind: framework === 'nextjs',
      
      // Deployment
      deployment: {
        useDocker: false,
        useCI: false
      },
      
      // Metadata
      metadata: {
        generatedBy: 'The Architech',
        generatedAt: new Date().toISOString(),
        userInput,
        options
      }
    };

    // Add workspaces for monorepo structure
    if (structure === 'monorepo') {
      baseConfig.workspaces = ['packages/*'];
    }

    return baseConfig;
  }

  /**
   * Get structure configuration for the project
   */
  getStructureConfig(config: ProjectConfiguration): StructureInfo {
    const userPreference = config.structure === 'monorepo' ? 'scalable-monorepo' : 'quick-prototype';
    
    return {
      type: config.structure,
      userPreference,
      isMonorepo: config.structure === 'monorepo',
      isSingleApp: config.structure === 'single-app',
      modules: config.modules,
      template: config.framework
    };
  }

  /**
   * Get template data for rendering
   */
  getTemplateData(config: ProjectConfiguration): Record<string, any> {
    return {
      projectName: config.name,
      packageManager: config.packageManager,
      template: config.framework,
      isMonorepo: config.structure === 'monorepo',
      framework: config.framework,
      features: config.features,
      modules: config.modules,
      scripts: config.scripts,
      dependencies: config.dependencies,
      devDependencies: config.devDependencies,
      workspaces: config.workspaces,
      typescript: config.typescript,
      eslint: config.eslint,
      prettier: config.prettier,
      tailwind: config.tailwind,
      deployment: config.deployment,
      metadata: config.metadata
    };
  }

  /**
   * Validate configuration
   */
  validateConfiguration(config: ProjectConfiguration): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Validate required fields
    if (!config.name) errors.push('Project name is required');
    if (!config.framework) errors.push('Framework is required');
    if (!config.structure) errors.push('Project structure is required');

    // Validate framework
    if (!this.isValidFramework(config.framework)) {
      errors.push(`Unsupported framework: ${config.framework}`);
    }

    // Validate structure
    if (!this.isValidStructure(config.structure)) {
      errors.push(`Unsupported structure: ${config.structure}`);
    }

    // Validate package manager
    if (!this.isValidPackageManager(config.packageManager)) {
      errors.push(`Unsupported package manager: ${config.packageManager}`);
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Save configuration to file
   */
  async saveConfiguration(
    projectPath: string,
    config: ProjectConfiguration
  ): Promise<void> {
    const configPath = path.join(projectPath, '.architech.json');
    
    try {
      await fsExtra.writeJson(configPath, config, { spaces: 2 });
      this.logger?.success(`Configuration saved to ${configPath}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger?.error(`Failed to save configuration: ${errorMessage}`, error as Error);
      throw error;
    }
  }

  /**
   * Load configuration from file
   */
  async loadConfiguration(projectPath: string): Promise<ProjectConfiguration | null> {
    const configPath = path.join(projectPath, '.architech.json');
    
    try {
      if (await fsExtra.pathExists(configPath)) {
        const config = await fsExtra.readJson(configPath);
        this.logger?.success(`Configuration loaded from ${configPath}`);
        return config;
      }
      return null;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger?.error(`Failed to load configuration: ${errorMessage}`, error as Error);
      return null;
    }
  }

  /**
   * Get default features for framework
   */
  private getDefaultFeatures(framework: string): string[] {
    const features: Record<string, string[]> = {
      'nextjs': ['typescript', 'tailwind', 'eslint', 'prettier', 'app-router'],
      'nextjs-14': ['typescript', 'tailwind', 'eslint', 'prettier', 'app-router'],
      'react': ['typescript', 'tailwind', 'eslint', 'prettier'],
      'vue': ['typescript', 'tailwind', 'eslint', 'prettier']
    };

    return features[framework] || ['typescript', 'eslint', 'prettier'];
  }

  /**
   * Get default modules for structure
   */
  private getDefaultModules(structure: ProjectStructure): string[] {
    if (structure === 'monorepo') {
      return ['ui', 'db', 'auth', 'config'];
    }
    return [];
  }

  /**
   * Get framework-specific configuration
   */
  private getFrameworkConfig(framework: string): Record<string, any> {
    const configs: Record<string, Record<string, any>> = {
      'nextjs': {
        appDir: true,
        experimental: {
          appDir: true,
          serverActions: true
        }
      },
      'nextjs-14': {
        appDir: true,
        experimental: {
          appDir: true,
          serverActions: true,
          typedRoutes: true
        }
      },
      'react': {
        jsx: 'react-jsx',
        strict: true
      },
      'vue': {
        jsx: 'preserve',
        strict: true
      }
    };

    return configs[framework] || {};
  }

  /**
   * Get default scripts for structure
   */
  private getDefaultScripts(structure: ProjectStructure): Record<string, string> {
    if (structure === 'monorepo') {
      return {
        'build': 'turbo run build',
        'dev': 'turbo run dev',
        'lint': 'turbo run lint',
        'lint:fix': 'turbo run lint:fix',
        'type-check': 'turbo run type-check',
        'format': 'turbo run format',
        'format:check': 'turbo run format:check',
        'clean': 'turbo run clean',
        'test': 'turbo run test',
        'test:watch': 'turbo run test:watch',
        'test:coverage': 'turbo run test:coverage'
      };
    } else {
      return {
        'dev': 'next dev',
        'build': 'next build',
        'start': 'next start',
        'lint': 'next lint',
        'lint:fix': 'next lint --fix',
        'type-check': 'tsc --noEmit',
        'format': 'prettier --write .',
        'format:check': 'prettier --check .',
        'clean': 'rm -rf .next out dist'
      };
    }
  }

  /**
   * Get default dependencies for framework
   */
  private getDefaultDependencies(framework: string): Record<string, string> {
    const dependencies: Record<string, Record<string, string>> = {
      'nextjs': {
        'next': '^14.2.0',
        'react': '^18.3.0',
        'react-dom': '^18.3.0'
      },
      'nextjs-14': {
        'next': '^14.2.0',
        'react': '^18.3.0',
        'react-dom': '^18.3.0'
      },
      'react': {
        'react': '^18.3.0',
        'react-dom': '^18.3.0'
      },
      'vue': {
        'vue': '^3.4.0'
      }
    };

    return dependencies[framework] || {};
  }

  /**
   * Get default dev dependencies for framework
   */
  private getDefaultDevDependencies(framework: string): Record<string, string> {
    const devDependencies: Record<string, Record<string, string>> = {
      'nextjs': {
        '@types/node': '^20.0.0',
        '@types/react': '^18.0.0',
        '@types/react-dom': '^18.0.0',
        'typescript': '^5.4.0',
        'eslint': '^8.57.0',
        'prettier': '^3.2.0',
        'tailwindcss': '^3.4.0',
        'autoprefixer': '^10.4.0',
        'postcss': '^8.4.0'
      },
      'nextjs-14': {
        '@types/node': '^20.0.0',
        '@types/react': '^18.0.0',
        '@types/react-dom': '^18.0.0',
        'typescript': '^5.4.0',
        'eslint': '^8.57.0',
        'prettier': '^3.2.0',
        'tailwindcss': '^3.4.0',
        'autoprefixer': '^10.4.0',
        'postcss': '^8.4.0'
      },
      'react': {
        '@types/node': '^20.0.0',
        '@types/react': '^18.0.0',
        '@types/react-dom': '^18.0.0',
        'typescript': '^5.4.0',
        'eslint': '^8.57.0',
        'prettier': '^3.2.0',
        'tailwindcss': '^3.4.0',
        'autoprefixer': '^10.4.0',
        'postcss': '^8.4.0'
      },
      'vue': {
        '@types/node': '^20.0.0',
        'typescript': '^5.4.0',
        'eslint': '^8.57.0',
        'prettier': '^3.2.0',
        'tailwindcss': '^3.4.0',
        'autoprefixer': '^10.4.0',
        'postcss': '^8.4.0'
      }
    };

    return devDependencies[framework] || {};
  }

  /**
   * Validate framework
   */
  private isValidFramework(framework: string): boolean {
    const validFrameworks = ['nextjs', 'nextjs-14', 'react', 'vue'];
    return validFrameworks.includes(framework);
  }

  /**
   * Validate structure
   */
  private isValidStructure(structure: ProjectStructure): boolean {
    return structure === 'single-app' || structure === 'monorepo';
  }

  /**
   * Validate package manager
   */
  private isValidPackageManager(packageManager: string): boolean {
    const validPackageManagers = ['npm', 'yarn', 'pnpm', 'bun', 'auto'];
    return validPackageManagers.includes(packageManager);
  }
} 